# smkitem implements the object model for SMK API items.
#
# Generated by https://app.quicktype.io/ from this URL
# https://api.smk.dk/api/v1/art/search/?keys=*&filters=%5Bpublic_domain%3Atrue%5D&offset=0&rows=10
#
# This code parses date/times, so please
#
#     pip install python-dateutil
#
# To use this code, make sure you
#
#     import json
#
# and then, to convert JSON from a string, do
#
#     result = smkitem_from_dict(json.loads(json_string))

from typing import Any, Optional, List, TypeVar, Callable, Type, cast
from datetime import datetime
import dateutil.parser


T = TypeVar("T")


def from_str(x: Any) -> str:
    assert isinstance(x, str)
    return x


def from_none(x: Any) -> Any:
    assert x is None
    return x


def from_union(fs, x):
    for f in fs:
        try:
            return f(x)
        except:
            pass
    assert False


def from_datetime(x: Any) -> datetime:
    return dateutil.parser.parse(x)


def from_list(f: Callable[[Any], T], x: Any) -> List[T]:
    assert isinstance(x, list)
    return [f(y) for y in x]


def from_bool(x: Any) -> bool:
    assert isinstance(x, bool)
    return x


def to_class(c: Type[T], x: Any) -> dict:
    assert isinstance(x, c)
    return cast(Any, x).to_dict()


def from_int(x: Any) -> int:
    assert isinstance(x, int) and not isinstance(x, bool)
    return x


class Facets:
    pass

    def __init__(self, ) -> None:
        pass

    @staticmethod
    def from_dict(obj: Any) -> 'Facets':
        assert isinstance(obj, dict)
        return Facets()

    def to_dict(self) -> dict:
        result: dict = {}
        return result


class Dimension:
    part: str
    type: str
    unit: str
    value: int

    def __init__(self, part: str, type: str, unit: str, value: int) -> None:
        self.part = part
        self.type = type
        self.unit = unit
        self.value = value

    @staticmethod
    def from_dict(obj: Any) -> 'Dimension':
        assert isinstance(obj, dict)
        part = from_str(obj.get("part"))
        type = from_str(obj.get("type"))
        unit = from_str(obj.get("unit"))
        value = int(from_str(obj.get("value")))
        return Dimension(part, type, unit, value)

    def to_dict(self) -> dict:
        result: dict = {}
        result["part"] = from_str(self.part)
        result["type"] = from_str(self.type)
        result["unit"] = from_str(self.unit)
        result["value"] = from_str(str(self.value))
        return result


class Documentation:
    title: str
    author: str
    notes: str
    shelfmark: str
    year_of_publication: int

    def __init__(self, title: str, author: str, notes: str, shelfmark: str, year_of_publication: int) -> None:
        self.title = title
        self.author = author
        self.notes = notes
        self.shelfmark = shelfmark
        self.year_of_publication = year_of_publication

    @staticmethod
    def from_dict(obj: Any) -> 'Documentation':
        assert isinstance(obj, dict)
        title = from_str(obj.get("title"))
        author = from_str(obj.get("author"))
        notes = from_str(obj.get("notes"))
        shelfmark = from_str(obj.get("shelfmark"))
        year_of_publication = int(from_str(obj.get("year_of_publication")))
        return Documentation(title, author, notes, shelfmark, year_of_publication)

    def to_dict(self) -> dict:
        result: dict = {}
        result["title"] = from_str(self.title)
        result["author"] = from_str(self.author)
        result["notes"] = from_str(self.notes)
        result["shelfmark"] = from_str(self.shelfmark)
        result["year_of_publication"] = from_str(str(self.year_of_publication))
        return result


class ObjectName:
    name: str

    def __init__(self, name: str) -> None:
        self.name = name

    @staticmethod
    def from_dict(obj: Any) -> 'ObjectName':
        assert isinstance(obj, dict)
        name = from_str(obj.get("name"))
        return ObjectName(name)

    def to_dict(self) -> dict:
        result: dict = {}
        result["name"] = from_str(self.name)
        return result


class Production:
    creator: str
    creator_forename: Optional[str]
    creator_surname: str
    creator_date_of_birth: datetime
    creator_date_of_death: datetime
    creator_nationality: str
    creator_gender: str
    creator_lref: str
    creator_history: Optional[str]
    creator_role: Optional[str]

    def __init__(self, creator: str, creator_forename: Optional[str], creator_surname: str, creator_date_of_birth: datetime, creator_date_of_death: datetime, creator_nationality: str, creator_gender: str, creator_lref: str, creator_history: Optional[str], creator_role: Optional[str]) -> None:
        self.creator = creator
        self.creator_forename = creator_forename
        self.creator_surname = creator_surname
        self.creator_date_of_birth = creator_date_of_birth
        self.creator_date_of_death = creator_date_of_death
        self.creator_nationality = creator_nationality
        self.creator_gender = creator_gender
        self.creator_lref = creator_lref
        self.creator_history = creator_history
        self.creator_role = creator_role

    @staticmethod
    def from_dict(obj: Any) -> 'Production':
        assert isinstance(obj, dict)
        creator = from_str(obj.get("creator"))
        creator_forename = from_union([from_str, from_none], obj.get("creator_forename"))
        creator_surname = from_str(obj.get("creator_surname"))
        creator_date_of_birth = from_datetime(obj.get("creator_date_of_birth"))
        creator_date_of_death = from_datetime(obj.get("creator_date_of_death"))
        creator_nationality = from_str(obj.get("creator_nationality"))
        creator_gender = from_str(obj.get("creator_gender"))
        creator_lref = from_str(obj.get("creator_lref"))
        creator_history = from_union([from_str, from_none], obj.get("creator_history"))
        creator_role = from_union([from_str, from_none], obj.get("creator_role"))
        return Production(creator, creator_forename, creator_surname, creator_date_of_birth, creator_date_of_death, creator_nationality, creator_gender, creator_lref, creator_history, creator_role)

    def to_dict(self) -> dict:
        result: dict = {}
        result["creator"] = from_str(self.creator)
        result["creator_forename"] = from_union([from_str, from_none], self.creator_forename)
        result["creator_surname"] = from_str(self.creator_surname)
        result["creator_date_of_birth"] = self.creator_date_of_birth.isoformat()
        result["creator_date_of_death"] = self.creator_date_of_death.isoformat()
        result["creator_nationality"] = from_str(self.creator_nationality)
        result["creator_gender"] = from_str(self.creator_gender)
        result["creator_lref"] = from_str(self.creator_lref)
        result["creator_history"] = from_union([from_str, from_none], self.creator_history)
        result["creator_role"] = from_union([from_str, from_none], self.creator_role)
        return result


class ProductionDate:
    start: datetime
    end: datetime
    period: str

    def __init__(self, start: datetime, end: datetime, period: str) -> None:
        self.start = start
        self.end = end
        self.period = period

    @staticmethod
    def from_dict(obj: Any) -> 'ProductionDate':
        assert isinstance(obj, dict)
        start = from_datetime(obj.get("start"))
        end = from_datetime(obj.get("end"))
        period = from_str(obj.get("period"))
        return ProductionDate(start, end, period)

    def to_dict(self) -> dict:
        result: dict = {}
        result["start"] = self.start.isoformat()
        result["end"] = self.end.isoformat()
        result["period"] = from_str(self.period)
        return result


class Title:
    title: str
    type: str
    language: str

    def __init__(self, title: str, type: str, language: str) -> None:
        self.title = title
        self.type = type
        self.language = language

    @staticmethod
    def from_dict(obj: Any) -> 'Title':
        assert isinstance(obj, dict)
        title = from_str(obj.get("title"))
        type = from_str(obj.get("type"))
        language = from_str(obj.get("language"))
        return Title(title, type, language)

    def to_dict(self) -> dict:
        result: dict = {}
        result["title"] = from_str(self.title)
        result["type"] = from_str(self.type)
        result["language"] = from_str(self.language)
        return result


class Item:
    id: str
    created: datetime
    modified: datetime
    responsible_department: str
    acquisition_date: datetime
    acquisition_date_precision: str
    dimensions: List[Dimension]
    documentation: List[Documentation]
    object_names: List[ObjectName]
    production: List[Production]
    production_date: List[ProductionDate]
    techniques: List[str]
    titles: List[Title]
    object_number: str
    object_url: str
    iiif_manifest: str
    enrichment_url: str
    similar_images_url: str
    production_dates_notes: List[str]
    public_domain: bool
    rights: str
    on_display: bool
    has_image: bool
    has_3_d_file: bool
    artist: List[str]

    def __init__(self, id: str, created: datetime, modified: datetime, responsible_department: str, acquisition_date: datetime, acquisition_date_precision: str, dimensions: List[Dimension], documentation: List[Documentation], object_names: List[ObjectName], production: List[Production], production_date: List[ProductionDate], techniques: List[str], titles: List[Title], object_number: str, object_url: str, iiif_manifest: str, enrichment_url: str, similar_images_url: str, production_dates_notes: List[str], public_domain: bool, rights: str, on_display: bool, has_image: bool, has_3_d_file: bool, artist: List[str]) -> None:
        self.id = id
        self.created = created
        self.modified = modified
        self.responsible_department = responsible_department
        self.acquisition_date = acquisition_date
        self.acquisition_date_precision = acquisition_date_precision
        self.dimensions = dimensions
        self.documentation = documentation
        self.object_names = object_names
        self.production = production
        self.production_date = production_date
        self.techniques = techniques
        self.titles = titles
        self.object_number = object_number
        self.object_url = object_url
        self.iiif_manifest = iiif_manifest
        self.enrichment_url = enrichment_url
        self.similar_images_url = similar_images_url
        self.production_dates_notes = production_dates_notes
        self.public_domain = public_domain
        self.rights = rights
        self.on_display = on_display
        self.has_image = has_image
        self.has_3_d_file = has_3_d_file
        self.artist = artist

    @staticmethod
    def from_dict(obj: Any) -> 'Item':
        assert isinstance(obj, dict)
        id = from_str(obj.get("id"))
        created = from_datetime(obj.get("created"))
        modified = from_datetime(obj.get("modified"))
        responsible_department = from_str(obj.get("responsible_department"))
        acquisition_date = from_datetime(obj.get("acquisition_date"))
        acquisition_date_precision = from_str(obj.get("acquisition_date_precision"))
        dimensions = from_list(Dimension.from_dict, obj.get("dimensions"))
        documentation = from_list(Documentation.from_dict, obj.get("documentation"))
        object_names = from_list(ObjectName.from_dict, obj.get("object_names"))
        production = from_list(Production.from_dict, obj.get("production"))
        production_date = from_list(ProductionDate.from_dict, obj.get("production_date"))
        techniques = from_list(from_str, obj.get("techniques"))
        titles = from_list(Title.from_dict, obj.get("titles"))
        object_number = from_str(obj.get("object_number"))
        object_url = from_str(obj.get("object_url"))
        iiif_manifest = from_str(obj.get("iiif_manifest"))
        enrichment_url = from_str(obj.get("enrichment_url"))
        similar_images_url = from_str(obj.get("similar_images_url"))
        production_dates_notes = from_list(from_str, obj.get("production_dates_notes"))
        public_domain = from_bool(obj.get("public_domain"))
        rights = from_str(obj.get("rights"))
        on_display = from_bool(obj.get("on_display"))
        has_image = from_bool(obj.get("has_image"))
        has_3_d_file = from_bool(obj.get("has_3d_file"))
        artist = from_list(from_str, obj.get("artist"))
        return Item(id, created, modified, responsible_department, acquisition_date, acquisition_date_precision, dimensions, documentation, object_names, production, production_date, techniques, titles, object_number, object_url, iiif_manifest, enrichment_url, similar_images_url, production_dates_notes, public_domain, rights, on_display, has_image, has_3_d_file, artist)

    def to_dict(self) -> dict:
        result: dict = {}
        result["id"] = from_str(self.id)
        result["created"] = self.created.isoformat()
        result["modified"] = self.modified.isoformat()
        result["responsible_department"] = from_str(self.responsible_department)
        result["acquisition_date"] = self.acquisition_date.isoformat()
        result["acquisition_date_precision"] = from_str(self.acquisition_date_precision)
        result["dimensions"] = from_list(lambda x: to_class(Dimension, x), self.dimensions)
        result["documentation"] = from_list(lambda x: to_class(Documentation, x), self.documentation)
        result["object_names"] = from_list(lambda x: to_class(ObjectName, x), self.object_names)
        result["production"] = from_list(lambda x: to_class(Production, x), self.production)
        result["production_date"] = from_list(lambda x: to_class(ProductionDate, x), self.production_date)
        result["techniques"] = from_list(from_str, self.techniques)
        result["titles"] = from_list(lambda x: to_class(Title, x), self.titles)
        result["object_number"] = from_str(self.object_number)
        result["object_url"] = from_str(self.object_url)
        result["iiif_manifest"] = from_str(self.iiif_manifest)
        result["enrichment_url"] = from_str(self.enrichment_url)
        result["similar_images_url"] = from_str(self.similar_images_url)
        result["production_dates_notes"] = from_list(from_str, self.production_dates_notes)
        result["public_domain"] = from_bool(self.public_domain)
        result["rights"] = from_str(self.rights)
        result["on_display"] = from_bool(self.on_display)
        result["has_image"] = from_bool(self.has_image)
        result["has_3d_file"] = from_bool(self.has_3_d_file)
        result["artist"] = from_list(from_str, self.artist)
        return result


class SMKItem:
    offset: int
    rows: int
    found: int
    items: List[Item]
    facets: Facets
    facets_ranges: Facets
    autocomplete: List[Any]

    def __init__(self, offset: int, rows: int, found: int, items: List[Item], facets: Facets, facets_ranges: Facets, autocomplete: List[Any]) -> None:
        self.offset = offset
        self.rows = rows
        self.found = found
        self.items = items
        self.facets = facets
        self.facets_ranges = facets_ranges
        self.autocomplete = autocomplete

    @staticmethod
    def from_dict(obj: Any) -> 'SMKItem':
        assert isinstance(obj, dict)
        offset = from_int(obj.get("offset"))
        rows = from_int(obj.get("rows"))
        found = from_int(obj.get("found"))
        items = from_list(Item.from_dict, obj.get("items"))
        facets = Facets.from_dict(obj.get("facets"))
        facets_ranges = Facets.from_dict(obj.get("facets_ranges"))
        autocomplete = from_list(lambda x: x, obj.get("autocomplete"))
        return SMKItem(offset, rows, found, items, facets, facets_ranges, autocomplete)

    def to_dict(self) -> dict:
        result: dict = {}
        result["offset"] = from_int(self.offset)
        result["rows"] = from_int(self.rows)
        result["found"] = from_int(self.found)
        result["items"] = from_list(lambda x: to_class(Item, x), self.items)
        result["facets"] = to_class(Facets, self.facets)
        result["facets_ranges"] = to_class(Facets, self.facets_ranges)
        result["autocomplete"] = from_list(lambda x: x, self.autocomplete)
        return result


def smkitem_from_dict(s: Any) -> SMKItem:
    return SMKItem.from_dict(s)


def smkitem_to_dict(x: SMKItem) -> Any:
    return to_class(SMKItem, x)
